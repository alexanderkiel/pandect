(ns ^ {:doc "Code Generation for Pandect"
       :author "Yannick Scherer"}
  pandect.gen.core
  (:import [java.io File FileInputStream InputStream]))

;; ## Concept
;;
;; Instead of having types that implement protocols that perform
;; the actual digest/checksum calculations (pandect <= 0.2.1), we
;; will have a protocol for code generators to be used to create
;; the digest/checksum functions in pandect.core at compile
;; time.

;; ## Protocol

(defprotocol CodeGen
  "Protocol for Pandect Code Generators."
  (algorithm-string [this]
    "Get String representing the Algorithm this Code Generator is built
     for.")
  (bytes->hash [this form]
    "Generate code to convert the byte array produced by the given form to 
     a value representing the given hash.")
  (stream->hash [this form]
    "Generate code to convert the input stream produced by the given form
     to a value representing the given hash.")
  (hash->string [this form]
    "Generate code to convert the hash value produced by the given form to
     a hex string.")
  (hash->bytes [this form]
    "Generate code to convert the hash value produced by the given form to
     a byte array."))

;; ## Multimethod

(defmulti code-generator
  "Get code generator for the given algorithm."
  (fn [algorithm] algorithm)
  :default nil)

(defmethod code-generator nil
  [x]
  (println "WARN: No such Code Generator: " x)
  nil)

;; ## Generation

(defn- generate-protocol-impl
  "Will generate a protocol that offers a single function generating an algorithm-
   specific hash value. Will also extend the following types to implement said
   protocol:
 
   - byte array
   - String
   - InputStream
   - File"
  [code-gen id f]
  (let [sym (gensym "this")
        P (vary-meta (gensym (str id "Hash")) assoc :private true)
        f (vary-meta f assoc :private true)]
    (vector 
      `(defprotocol ~P
         ~(str "Protocol for " (algorithm-string code-gen) " hash generation.")
        (~f [this#]))
      `(extend-protocol ~P
         (class (byte-array 0))
         (~f [~sym]
           ~(bytes->hash code-gen sym))
         String
         (~f [~sym]
           ~(bytes->hash code-gen `(.getBytes ~sym)))
         InputStream
         (~f [~sym]
           ~(stream->hash code-gen sym))
         File
         (~f [this#]
           (with-open [~sym (FileInputStream. this#)]
             ~(stream->hash code-gen sym)))
         nil
         (~f [this#]
           nil)))))

(defn- generate-compute-fns
  "Generate functions that call a prviously created hash function and wrap the result
   in string/byte conversions. The created functions, based on an id X, will be:
   
   - `X` : outputs hex string
   - `X-bytes` : outputs byte array
   - `X-file` : input is path to file, outputs string
   - `X-file-bytes` : input is path to file, outputs byte array
   - `X*` : outputs the actual hash value generated by the given function
   - `X*-file` : input is path to file, outputs the actual hash value generated by the given function
  "
  [code-gen id f]
  (let [id-bytes (symbol (str id "-bytes"))
        id-file (symbol (str id "-file"))
        id-file-bytes (symbol (str id "-file-bytes"))
        id-raw (symbol (str id "*"))
        id-raw-file (symbol (str id "*-file"))
        sym (gensym "v")]
    (vector
      `(defn ~id-raw [~sym] (~f ~sym))
      `(defn ~id-raw-file [~sym] (~f (File. (str ~sym))))
      `(defn ~id-bytes [~sym] ~(hash->bytes code-gen `(~f ~sym)))
      `(defn ~id-file [~sym] ~(hash->string code-gen `(~f (File. (str ~sym)))))
      `(defn ~id-file-bytes [~sym] ~(hash->bytes code-gen `(~f (File. (str ~sym)))))
      `(defn ~id [~sym] ~(hash->string code-gen `(~f ~sym))))))

(defn generate-hash
  "Generate protocol and computing functions using the give code generator and
   function id."
  [code-gen id]
  (let [sym (gensym "this")
        f (gensym (str "compute-" id))]
    `(do
       ~@(generate-protocol-impl code-gen id f)
       ~@(generate-compute-fns code-gen id f))))
